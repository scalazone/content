## Welcome

Welcome to _Learning to code in Scala_, an evolving online course which, over the next months, aims to teach
every detail of the Scala language, from the very fundamentals of programming, through the subtle finer details
of the syntax and runtime, to advanced topics like metaprogramming and type theory.

_Learning to code in Scala_ is launching with twenty beginner-level lessons, and will expand through 2020 and
2021 to offer over a hundred lessons covering every facet of Scala at beginner, intermediate and advanced
level, organized into topics, and each one linked to the prerequisites that need to be understood before that
lesson.

Although ScalaZONE will encourage starting at the beginning of one of the course levels, and then guide you
through the topics in a meaningful order, access to all learning material is completely open, and you can always
navigate or link to any lesson directly.

## Why Scala?

But first, let's look at why we might like to learn Scala at all.

Scala is a high-level language which can run on the Java Virtual Machine, in a web browser or natively. It has
a versatile syntax that offers rich domain-modeling possibilities, combined with a powerful type system that
can encode precise constraints on the behavior of our code.

Scala embraces both functional and object-oriented styles of programming, with extensive support for FP features
familiar to Haskell or F# users, such as immutability, functions as values, and first-class syntax for working
with monads, at the same time as facilitating OOP ideas familiar to Java, Kotlin, Python or C# developers such
as inheritance, polymorphism, the idea that "everything is an object", not to mention access to the extensive
Java ecosystem of libraries.

This combination of features makes Scala an extremely interesting hybrid language that can offer a wealth of
possibilities for developers working in a wide variety of fields, from large distributed cloud-based
applications to small command-line tools.

## My experience of Scala

When I first started programming in an early version of Scala in 2004, I found its new features interesting and
exciting, and like many users who had worked with Java, it seemed _familiar_, while opening me up a new world of
opportunities through concepts I was yet to discover.

As my experience with Scala grew, and I started to take full advantage of its many features, I found that, above
all, Scala gave me _confidence_ as a programmer which I had not experienced with other programming languages.

That experience of confidence stemmed from the killer combination of _expressive syntax_ and a
_powerful static type system_: I could describe data and behavior using language that was easy to write and
read, closely mirroring the domain I was working in, while the type system would enforce the constraints and
invariants I relied on for my software to function correctly.

This proved to be most effective when changing my code: I could take a working program and make trivial or
dramatic modifications to it, but the Scala compiler would ensure that I couldn't compile code that was _wrong_:
Scala's type system was capable of identifying and forcing me to correct the vast majority of mistakes (many
of them quite subtle) _before_ I could even attempt to run my software.

So Scala became, for me, a language optimized for _resilience under maintenance_: a language which emboldened
me to attempt more significant refactorings or the addition of new features, confident in the knowledge that the
compiler would not allow me to shoot myself in the foot, and would instead guide me towards ensuring the
self-consistency of my software.

In an industry where the ability to respond to change _quickly_ is paramount, yet where reliability is far from
guaranteed, Scala should be enormously welcome.

## Scala Today

Today, Scala is one of the most widely used languages for backend development, particularly for
high-performance distributed scalable systems. Developers who write Scala can be more effective than developers
in many other languages, and many organizations see Scala development skills not only as valuable asset for any
developer, but a good indicator of a developer's capability in general.

Scala is a language with great depth, and while a new Scala developer can be productive within days of starting
to learn the language, Scala can offer that same developer a continual learning experience lasting years, all
the while gaining proficiency.

And that is a _joyful_ experience for any software developer!

## Scala 3

This course, while much of it will be relevant to earlier versions of Scala, teaches Scala 3, the latest version
of Scala. Scala 3 represents the biggest collection of new features, simplifications and bugfixes to the
language in a decade, delivered through a completely-rewritten compiler.

Scala 3 builds upon the success of Scala 2, which proved itself through numerous successful deployments in a
variety of industries, and they are one language: backwards- and forwards-compatible. But Scala 3 also _learns_
from the experience tens of thousands of developers had with Scala 2, and simplifies many details of the
language which could confuse beginners or which could frustrate experienced users.

Scala 3 also builds upon a more principled set of foundations than its earlier incarnation: a selection of new
metaprogramming tools replace the powerful but fragile macros, and Scala 3's type system is built upon the
_DOT Calculus_, proven to be _sound_ as part of the extensive research that went into the development of
Scala 3.

So let's begin. Good luck, and enjoy the course!

?---?

# Throughout the course, questions will appear at the bottom of each lesson, to test whether you have understood the concepts in the lesson.

Some of these require you to select a single answer. So try this with an easy question now: choose the language
you would like to learn.

- [ ] F#
- [ ] Haskell
- [X] Scala
- [ ] Java
- [ ] Kotlin
- [ ] C#

# Other questions allow you to choose multiple answers.

These are usually harder because, in order to get the question right, you must consider each and every possible
answer. Try this one now: select every programming language containing the letter `a` in its name.

* [ ] F#
* [X] Haskell
* [X] Scala
* [X] Java
* [ ] Kotlin
* [ ] C#
